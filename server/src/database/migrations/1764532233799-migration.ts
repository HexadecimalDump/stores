/* eslint-disable @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-return */
import { MigrationInterface, QueryRunner } from 'typeorm';

export class Migration1764532233799 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // 1. Insert Products first, as the Store-Product relationship depends on existing product IDs.

    // Define the products data
    const products = [
      { name: 'Laptop', category: 'Electronics', price: 999.99, qty: 50 },
      { name: 'T-Shirt', category: 'Apparel', price: 19.99, qty: 200 },
      { name: 'Coffee Mug', category: 'Homeware', price: 8.5, qty: 150 },
      { name: 'Notebook', category: 'Stationery', price: 4.99, qty: 300 },
      { name: 'Smartphone', category: 'Electronics', price: 699.99, qty: 120 },
      { name: 'Headphones', category: 'Electronics', price: 150.0, qty: 85 },
      { name: 'Jeans', category: 'Apparel', price: 45.5, qty: 180 },
      { name: 'Sneakers', category: 'Apparel', price: 75.0, qty: 90 },
      { name: 'Desk Chair', category: 'Furniture', price: 250.0, qty: 40 },
      { name: 'Keyboard', category: 'Accessories', price: 80.0, qty: 110 },
      { name: 'Mouse', category: 'Accessories', price: 30.0, qty: 150 },
      { name: 'Water Bottle', category: 'Homeware', price: 12.0, qty: 250 },
      { name: 'Backpack', category: 'Accessories', price: 60.0, qty: 70 },
      { name: 'Sunglasses', category: 'Apparel', price: 95.0, qty: 60 },
    ];

    // Prepare values for bulk insert SQL statement
    const productValues = products
      .map(
        (p) =>
          `('${p.name}', '${p.category}', ${p.price}, ${p.qty}, NOW(), NOW())`,
      )
      .join(', ');

    // Use queryRunner.query for efficient bulk insert (one query for all products)
    // The RETURNING clause is used to fetch the new IDs
    const insertedProducts = await queryRunner.query(
      `
      INSERT INTO product (name, category, price, qty, "createdAt", "updatedAt")
      VALUES ${productValues}
      RETURNING id
      `,
    );

    // Extract the IDs from the result
    const productIds = insertedProducts.map((row: any) => row.id);

    // 2. Insert Stores

    // Define the stores data
    const stores = [{ name: 'Tech Store' }, { name: 'General Goods Co.' }];

    const insertedStores = await queryRunner.query(
      `
      INSERT INTO store (name, "createdAt", "updatedAt")
      VALUES 
      ($1, NOW(), NOW()),
      ($2, NOW(), NOW())
      RETURNING id
      `,
      [stores[0].name, stores[1].name],
    );

    // Extract the IDs from the result
    const storeIds = insertedStores.map((row: any) => row.id);

    // 3. Link Stores and Products in the Many-to-Many Join Table
    // The join table is automatically generated by TypeORM and likely named `store_products_product` or similar,
    // where the columns are `storeId` and `productId`. We will assume the default TypeORM naming conventions.

    // Tech Store (ID 1) sells Laptop (ID 1), T-Shirt (ID 2), and Notebook (ID 4)
    // General Goods Co. (ID 2) sells everything (IDs 1, 2, 3, 4)

    await queryRunner.query(
      `
      INSERT INTO store_products_product ("storeId", "productId")
      VALUES 
      ($1, $3),
      ($1, $4),
      ($1, $6),
      ($2, $3),
      ($2, $4),
      ($2, $5),
      ($2, $6)
      `,
      [
        storeIds[0], // Store 1 ID
        storeIds[1], // Store 2 ID
        productIds[0], // Product 1 ID
        productIds[1], // Product 2 ID
        productIds[2], // Product 3 ID
        productIds[3], // Product 4 ID
      ],
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Optional: add logic to revert the seeding when rolling back the migration
    // Delete the join table entries first, then the entities themselves.
    await queryRunner.query(`DELETE FROM store_products_product;`);
    await queryRunner.query(`DELETE FROM store;`);
    await queryRunner.query(`DELETE FROM product;`);
  }
}
